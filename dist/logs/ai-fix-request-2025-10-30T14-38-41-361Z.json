{
  "messages": [
    {
      "role": "system",
      "content": "Você é um especialista em testes unitários para Angular com Jest e TypeScript. \nSua tarefa é analisar e corrigir testes unitários que falharam na execução.\n\nIMPORTANTE:\n- Analise cuidadosamente o erro de execução fornecido\n- Identifique a CAUSA RAIZ do erro (imports faltando, configurações incorretas, etc.)\n- CORRIJA o teste para que ele execute com sucesso\n- Use as melhores práticas do Jest e Angular Testing\n- Certifique-se de que TODOS os imports necessários estão presentes\n- Verifique se o TestBed está configurado corretamente\n- Se o componente é standalone, certifique-se de incluir no array imports do TestBed\n- Adicione TODOS os mocks necessários\n\nRESPOSTA:\nResponda SOMENTE com o CÓDIGO DO TESTE corrigido, sem markdown, sem JSON, sem explicações. Não envolva em cercas de código."
    },
    {
      "role": "user",
      "content": "Por favor, analise e CORRIJA o seguinte teste unitário que falhou na execução:\n\nCOMPONENTE ORIGINAL:\n```typescript\nimport { Component, computed, signal } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport { FormsModule } from '@angular/forms';\r\n\r\n@Component({\r\n  selector: 'app-math-suite',\r\n  standalone: true,\r\n  imports: [CommonModule, FormsModule],\r\n  templateUrl: './math-suite.component.html',\r\n  styleUrl: './math-suite.component.scss'\r\n})\r\nexport class MathSuiteComponent {\r\n  a = signal<number>(12);\r\n  b = signal<number>(8);\r\n\r\n  sum = computed(() => this.a() + this.b());\r\n  diff = computed(() => this.a() - this.b());\r\n  prod = computed(() => this.a() * this.b());\r\n  quot = computed(() => (this.b() === 0 ? NaN : this.a() / this.b()));\r\n  pow = computed(() => Math.pow(this.a(), this.b()));\r\n\r\n  gcd = computed(() => this.computeGcd(this.a(), this.b()));\r\n  lcm = computed(() => {\r\n    const g = this.gcd();\r\n    return g === 0 ? 0 : Math.abs(this.a() * this.b()) / g;\r\n  });\r\n\r\n  isAPrime = computed(() => this.isPrime(this.a()));\r\n  isBPrime = computed(() => this.isPrime(this.b()));\r\n\r\n  factorialA = computed(() => this.factorialSafe(this.a()));\r\n  factorialB = computed(() => this.factorialSafe(this.b()));\r\n\r\n  fibA = computed(() => this.fibonacciSafe(this.a()));\r\n  fibB = computed(() => this.fibonacciSafe(this.b()));\r\n\r\n  setA(value: number | string): void {\r\n    const num = Number(value);\r\n    if (!Number.isNaN(num)) this.a.set(num);\r\n  }\r\n\r\n  setB(value: number | string): void {\r\n    const num = Number(value);\r\n    if (!Number.isNaN(num)) this.b.set(num);\r\n  }\r\n\r\n  private computeGcd(x: number, y: number): number {\r\n    x = Math.abs(x);\r\n    y = Math.abs(y);\r\n    while (y !== 0) {\r\n      const t = y;\r\n      y = x % y;\r\n      x = t;\r\n    }\r\n    return x;\r\n  }\r\n\r\n  private isPrime(n: number): boolean {\r\n    n = Math.floor(n);\r\n    if (n <= 1) return false;\r\n    if (n <= 3) return true;\r\n    if (n % 2 === 0 || n % 3 === 0) return false;\r\n    for (let i = 5; i * i <= n; i += 6) {\r\n      if (n % i === 0 || n % (i + 2) === 0) return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  private factorialSafe(n: number): number | string {\r\n    n = Math.floor(n);\r\n    if (n < 0) return 'NaN';\r\n    if (n > 20) return 'Overflow';\r\n    let res = 1;\r\n    for (let i = 2; i <= n; i++) res *= i;\r\n    return res;\r\n  }\r\n\r\n  private fibonacciSafe(n: number): number | string {\r\n    n = Math.floor(n);\r\n    if (n < 0) return 'NaN';\r\n    if (n > 70) return 'Overflow';\r\n    if (n === 0) return 0;\r\n    if (n === 1) return 1;\r\n    let a = 0;\r\n    let b = 1;\r\n    for (let i = 2; i <= n; i++) {\r\n      const next = a + b;\r\n      a = b;\r\n      b = next;\r\n    }\r\n    return b;\r\n  }\r\n}\r\n\r\n\r\n\n```\n\nTESTE ATUAL (COM ERRO):\n```typescript\nimport { TestBed } from '@angular/core/testing';\nimport { MathSuiteComponent } from './math-suite.component';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\n\ndescribe('MathSuiteComponent', () => {\n  let component: MathSuiteComponent;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [MathSuiteComponent, CommonModule, FormsModule]\n    });\n    // Get a fresh instance each test\n    const fixture = TestBed.createComponent(MathSuiteComponent);\n    component = fixture.componentInstance;\n  });\n\n  it('should create', () => {\n    expect(component).toBeTruthy();\n  });\n\n  describe('Initial signal values', () => {\n    it('should have initial a=12 and b=8', () => {\n      expect(component.a()).toBe(12);\n      expect(component.b()).toBe(8);\n    });\n  });\n\n  describe('Basic math computed signals', () => {\n    it('should compute sum', () => {\n      expect(component.sum()).toBe(20);\n    });\n\n    it('should compute diff', () => {\n      expect(component.diff()).toBe(4);\n    });\n\n    it('should compute prod', () => {\n      expect(component.prod()).toBe(96);\n    });\n\n    it('should compute quot', () => {\n      expect(component.quot()).toBe(1.5);\n    });\n\n    it('should return NaN for quot when b=0', () => {\n      component.setB(0);\n      expect(component.quot()).toEqual(jasmine.any(Number));\n      expect(isNaN(component.quot())).toBeTrue();\n    });\n\n    it('should compute pow', () => {\n      expect(component.pow()).toBe(Math.pow(12, 8));\n    });\n  });\n\n  describe('GCD and LCM', () => {\n    it('should compute gcd correctly', () => {\n      expect(component.gcd()).toBe(4);\n      component.setA(9);\n      component.setB(6);\n      expect(component.gcd()).toBe(3);\n    });\n\n    it('should compute lcm correctly', () => {\n      expect(component.lcm()).toBe(24);\n      component.setA(9);\n      component.setB(6);\n      expect(component.lcm()).toBe(18);\n    });\n\n    it('should return lcm=0 when gcd is 0 (a=0, b=0)', () => {\n      component.setA(0);\n      component.setB(0);\n      expect(component.gcd()).toBe(0);\n      expect(component.lcm()).toBe(0);\n    });\n  });\n\n  describe('Primality computed signals', () => {\n    it('should check if a is prime', () => {\n      component.setA(7);\n      expect(component.isAPrime()).toBeTrue();\n      component.setA(12);\n      expect(component.isAPrime()).toBeFalse();\n      component.setA(1);\n      expect(component.isAPrime()).toBeFalse();\n    });\n\n    it('should check if b is prime', () => {\n      component.setB(13);\n      expect(component.isBPrime()).toBeTrue();\n      component.setB(8);\n      expect(component.isBPrime()).toBeFalse();\n    });\n  });\n\n  describe('Factorial computed signals', () => {\n    it('should compute factorialA for valid n', () => {\n      component.setA(5);\n      expect(component.factorialA()).toBe(120);\n    });\n\n    it('should return \"NaN\" for factorialA when n < 0', () => {\n      component.setA(-2);\n      expect(component.factorialA()).toBe('NaN');\n    });\n\n    it('should return \"Overflow\" for factorialA when n > 20', () => {\n      component.setA(21);\n      expect(component.factorialA()).toBe('Overflow');\n    });\n\n    it('should compute factorialB for valid n', () => {\n      component.setB(4);\n      expect(component.factorialB()).toBe(24);\n    });\n  });\n\n  describe('Fibonacci computed signals', () => {\n    it('should compute fibA for valid n', () => {\n      component.setA(7);\n      expect(component.fibA()).toBe(13);\n    });\n\n    it('should return \"NaN\" for fibA when n < 0', () => {\n      component.setA(-10);\n      expect(component.fibA()).toBe('NaN');\n    });\n\n    it('should return \"Overflow\" for fibA when n > 70', () => {\n      component.setA(71);\n      expect(component.fibA()).toBe('Overflow');\n    });\n\n    it('should compute fibB for valid n', () => {\n      component.setB(10);\n      expect(component.fibB()).toBe(55);\n    });\n  });\n\n  describe('setA and setB methods', () => {\n    it('should update a with setA (number)', () => {\n      component.setA(99);\n      expect(component.a()).toBe(99);\n    });\n\n    it('should update b with setB (string number)', () => {\n      component.setB(\"123\");\n      expect(component.b()).toBe(123);\n    });\n\n    it('should ignore NaN input in setA/setB', () => {\n      const prevA = component.a();\n      const prevB = component.b();\n      component.setA(\"not-a-number\");\n      component.setB({});\n      expect(component.a()).toBe(prevA);\n      expect(component.b()).toBe(prevB);\n    });\n  });\n});\n```\n\nERRO DE EXECUÇÃO:\nErro na execução do teste:\n\nts-jest[config] (WARN) \u001b[94mmessage\u001b[0m\u001b[90m TS151001: \u001b[0mIf you have issues related to imports, you should consider setting `esModuleInterop` to `true` in your TypeScript configuration file (usually `tsconfig.json`). See https://blogs.msdn.microsoft.com/typescript/2018/01/31/announcing-typescript-2-7/#easier-ecmascript-module-interoperability for more information.\nFAIL src/app/math-suite/math-suite.component.spec.ts\n  MathSuiteComponent\n    √ should create (86 ms)\n    Initial signal values\n      √ should have initial a=12 and b=8 (12 ms)\n    Basic math computed signals\n      √ should compute sum (10 ms)\n      √ should compute diff (12 ms)\n      √ should compute prod (13 ms)\n      √ should compute quot (9 ms)\n      × should return NaN for quot when b=0 (8 ms)\n      √ should compute pow (9 ms)\n    GCD and LCM\n      √ should compute gcd correctly (10 ms)\n      √ should compute lcm correctly (9 ms)\n      √ should return lcm=0 when gcd is 0 (a=0, b=0) (8 ms)\n    Primality computed signals\n      × should check if a is prime (10 ms)\n      × should check if b is prime (11 ms)\n    Factorial computed signals\n      √ should compute factorialA for valid n (10 ms)\n      √ should return \"NaN\" for factorialA when n < 0 (7 ms)\n      √ should return \"Overflow\" for factorialA when n > 20 (9 ms)\n      √ should compute factorialB for valid n (11 ms)\n    Fibonacci computed signals\n      √ should compute fibA for valid n (9 ms)\n      √ should return \"NaN\" for fibA when n < 0 (8 ms)\n      √ should return \"Overflow\" for fibA when n > 70 (6 ms)\n      √ should compute fibB for valid n (7 ms)\n    setA and setB methods\n      √ should update a with setA (number) (10 ms)\n      √ should update b with setB (string number) (7 ms)\n      √ should ignore NaN input in setA/setB (8 ms)\n\n  ● MathSuiteComponent › Basic math computed signals › should return NaN for quot when b=0\n\n    ReferenceError: jasmine is not defined\n\n    \u001b[0m \u001b[90m 46 |\u001b[39m     it(\u001b[32m'should return NaN for quot when b=0'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\n     \u001b[90m 47 |\u001b[39m       component\u001b[33m.\u001b[39msetB(\u001b[35m0\u001b[39m)\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 48 |\u001b[39m       expect(component\u001b[33m.\u001b[39mquot())\u001b[33m.\u001b[39mtoEqual(jasmine\u001b[33m.\u001b[39many(\u001b[33mNumber\u001b[39m))\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                                        \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 49 |\u001b[39m       expect(isNaN(component\u001b[33m.\u001b[39mquot()))\u001b[33m.\u001b[39mtoBeTrue()\u001b[33m;\u001b[39m\n     \u001b[90m 50 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 51 |\u001b[39m\u001b[0m\n\n      at src/app/math-suite/math-suite.component.spec.ts:48:40\n      at _ZoneDelegate.invoke (node_modules/zone.js/bundles/zone.umd.js:410:32)\n      at ProxyZoneSpec.onInvoke (node_modules/zone.js/bundles/zone-testing.umd.js:2219:43)\n      at _ZoneDelegate.invoke (node_modules/zone.js/bundles/zone.umd.js:409:38)\n      at ZoneImpl.run (node_modules/zone.js/bundles/zone.umd.js:145:47)\n      at Object.wrappedFunc (node_modules/zone.js/bundles/zone-testing.umd.js:449:38)\n\n  ● MathSuiteComponent › Primality computed signals › should check if a is prime\n\n    TypeError: expect(...).toBeTrue is not a function\n\n    \u001b[0m \u001b[90m 81 |\u001b[39m     it(\u001b[32m'should check if a is prime'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\n     \u001b[90m 82 |\u001b[39m       component\u001b[33m.\u001b[39msetA(\u001b[35m7\u001b[39m)\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 83 |\u001b[39m       expect(component\u001b[33m.\u001b[39misAPrime())\u001b[33m.\u001b[39mtoBeTrue()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                                    \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 84 |\u001b[39m       component\u001b[33m.\u001b[39msetA(\u001b[35m12\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 85 |\u001b[39m       expect(component\u001b[33m.\u001b[39misAPrime())\u001b[33m.\u001b[39mtoBeFalse()\u001b[33m;\u001b[39m\n     \u001b[90m 86 |\u001b[39m       component\u001b[33m.\u001b[39msetA(\u001b[35m1\u001b[39m)\u001b[33m;\u001b[39m\u001b[0m\n\n      at src/app/math-suite/math-suite.component.spec.ts:83:36\n      at _ZoneDelegate.invoke (node_modules/zone.js/bundles/zone.umd.js:410:32)\n      at ProxyZoneSpec.onInvoke (node_modules/zone.js/bundles/zone-testing.umd.js:2219:43)\n      at _ZoneDelegate.invoke (node_modules/zone.js/bundles/zone.umd.js:409:38)\n      at ZoneImpl.run (node_modules/zone.js/bundles/zone.umd.js:145:47)\n      at Object.wrappedFunc (node_modules/zone.js/bundles/zone-testing.umd.js:449:38)\n\n  ● MathSuiteComponent › Primality computed signals › should check if b is prime\n\n    TypeError: expect(...).toBeTrue is not a function\n\n    \u001b[0m \u001b[90m 90 |\u001b[39m     it(\u001b[32m'should check if b is prime'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\n     \u001b[90m 91 |\u001b[39m       component\u001b[33m.\u001b[39msetB(\u001b[35m13\u001b[39m)\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 92 |\u001b[39m       expect(component\u001b[33m.\u001b[39misBPrime())\u001b[33m.\u001b[39mtoBeTrue()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                                    \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 93 |\u001b[39m       component\u001b[33m.\u001b[39msetB(\u001b[35m8\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 94 |\u001b[39m       expect(component\u001b[33m.\u001b[39misBPrime())\u001b[33m.\u001b[39mtoBeFalse()\u001b[33m;\u001b[39m\n     \u001b[90m 95 |\u001b[39m     })\u001b[33m;\u001b[39m\u001b[0m\n\n      at src/app/math-suite/math-suite.component.spec.ts:92:36\n      at _ZoneDelegate.invoke (node_modules/zone.js/bundles/zone.umd.js:410:32)\n      at ProxyZoneSpec.onInvoke (node_modules/zone.js/bundles/zone-testing.umd.js:2219:43)\n      at _ZoneDelegate.invoke (node_modules/zone.js/bundles/zone.umd.js:409:38)\n      at ZoneImpl.run (node_modules/zone.js/bundles/zone.umd.js:145:47)\n      at Object.wrappedFunc (node_modules/zone.js/bundles/zone-testing.umd.js:449:38)\n\nTest Suites: 1 failed, 1 total\nTests:       3 failed, 21 passed, 24 total\nSnapshots:   0 total\nTime:        3.065 s\nRan all test suites matching C:\\Users\\iago_\\Desktop\\Projects\\AutoUnitTest\\v1\\test-angular/src\\app\\math-suite\\math-suite.component.spec.ts.\n\n\nPor favor, corrija o teste para que ele execute com sucesso.\n\nINFORMAÇÕES CRÍTICAS PARA IMPORTS:\n- Nome do componente: math-suite.component\n- Arquivo do componente original: C:\\Users\\iago_\\Desktop\\Projects\\AutoUnitTest\\v1\\test-angular/src\\app\\math-suite\\math-suite.component.ts\n- Nome do arquivo do componente: math-suite.component.ts\n- Nome base do arquivo: math-suite.component\n- Arquivo de teste esperado: math-suite.component.spec.ts\n\nREGRA DE OURO PARA IMPORTS (ATENÇÃO - SIGA EXATAMENTE):\nO import CORRETO do componente deve ser APENAS:\n\nimport { math-suite.component } from './math-suite.component';\n\n❌ NÃO use: './math-suite.component.component'\n❌ NÃO use: './math-suite.component.component'  \n❌ NÃO use: './math-suite.component.component'\n✅ USE APENAS: './math-suite.component'\n\nEXEMPLO:\nSe o arquivo é delsuc.ts, o import correto é:\nimport { Delsuc } from './delsuc';\n\nSe o arquivo é calculator.component.ts, o import correto é:\nimport { CalculatorComponent } from './calculator.component';\n\nINSTRUÇÕES:\n1. Analise o erro de execução fornecido acima\n2. Identifique a CAUSA RAIZ do problema\n3. CORRIJA o import do componente para usar APENAS o nome base do arquivo\n4. Se o erro for \"Cannot find module\", substitua o import errado pelo import correto mostrado acima\n5. Se o erro for relacionado a TestBed, configure corretamente os imports\n6. Se o componente é standalone, certifique-se de incluí-lo no array imports do TestBed.configureTestingModule\n7. Adicione todos os mocks e providers necessários\n8. Gere um teste COMPLETO, EXECUTÁVEL e CORRETO com o import CORRETO\n9. **VERIFIQUE que TODOS os blocos de código estão fechados corretamente (chaves, parênteses)**\n10. **Garanta que a função describe(), beforeEach() e it() estão TODAS fechadas com })"
    }
  ],
  "model": "gpt-3.5-turbo",
  "temperature": 0.7,
  "max_tokens": 2000
}