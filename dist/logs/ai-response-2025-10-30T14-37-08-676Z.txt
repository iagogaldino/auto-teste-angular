import { TestBed } from '@angular/core/testing';
import { MathSuiteComponent } from './math-suite.component';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';

describe('MathSuiteComponent', () => {
  let component: MathSuiteComponent;

  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [MathSuiteComponent, CommonModule, FormsModule]
    });
    // Get a fresh instance each test
    const fixture = TestBed.createComponent(MathSuiteComponent);
    component = fixture.componentInstance;
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });

  describe('Initial signal values', () => {
    it('should have initial a=12 and b=8', () => {
      expect(component.a()).toBe(12);
      expect(component.b()).toBe(8);
    });
  });

  describe('Basic math computed signals', () => {
    it('should compute sum', () => {
      expect(component.sum()).toBe(20);
    });

    it('should compute diff', () => {
      expect(component.diff()).toBe(4);
    });

    it('should compute prod', () => {
      expect(component.prod()).toBe(96);
    });

    it('should compute quot', () => {
      expect(component.quot()).toBe(1.5);
    });

    it('should return NaN for quot when b=0', () => {
      component.setB(0);
      expect(component.quot()).toEqual(jasmine.any(Number));
      expect(isNaN(component.quot())).toBeTrue();
    });

    it('should compute pow', () => {
      expect(component.pow()).toBe(Math.pow(12, 8));
    });
  });

  describe('GCD and LCM', () => {
    it('should compute gcd correctly', () => {
      expect(component.gcd()).toBe(4);
      component.setA(9);
      component.setB(6);
      expect(component.gcd()).toBe(3);
    });

    it('should compute lcm correctly', () => {
      expect(component.lcm()).toBe(24);
      component.setA(9);
      component.setB(6);
      expect(component.lcm()).toBe(18);
    });

    it('should return lcm=0 when gcd is 0 (a=0, b=0)', () => {
      component.setA(0);
      component.setB(0);
      expect(component.gcd()).toBe(0);
      expect(component.lcm()).toBe(0);
    });
  });

  describe('Primality computed signals', () => {
    it('should check if a is prime', () => {
      component.setA(7);
      expect(component.isAPrime()).toBeTrue();
      component.setA(12);
      expect(component.isAPrime()).toBeFalse();
      component.setA(1);
      expect(component.isAPrime()).toBeFalse();
    });

    it('should check if b is prime', () => {
      component.setB(13);
      expect(component.isBPrime()).toBeTrue();
      component.setB(8);
      expect(component.isBPrime()).toBeFalse();
    });
  });

  describe('Factorial computed signals', () => {
    it('should compute factorialA for valid n', () => {
      component.setA(5);
      expect(component.factorialA()).toBe(120);
    });

    it('should return "NaN" for factorialA when n < 0', () => {
      component.setA(-2);
      expect(component.factorialA()).toBe('NaN');
    });

    it('should return "Overflow" for factorialA when n > 20', () => {
      component.setA(21);
      expect(component.factorialA()).toBe('Overflow');
    });

    it('should compute factorialB for valid n', () => {
      component.setB(4);
      expect(component.factorialB()).toBe(24);
    });
  });

  describe('Fibonacci computed signals', () => {
    it('should compute fibA for valid n', () => {
      component.setA(7);
      expect(component.fibA()).toBe(13);
    });

    it('should return "NaN" for fibA when n < 0', () => {
      component.setA(-10);
      expect(component.fibA()).toBe('NaN');
    });

    it('should return "Overflow" for fibA when n > 70', () => {
      component.setA(71);
      expect(component.fibA()).toBe('Overflow');
    });

    it('should compute fibB for valid n', () => {
      component.setB(10);
      expect(component.fibB()).toBe(55);
    });
  });

  describe('setA and setB methods', () => {
    it('should update a with setA (number)', () => {
      component.setA(99);
      expect(component.a()).toBe(99);
    });

    it('should update b with setB (string number)', () => {
      component.setB("123");
      expect(component.b()).toBe(123);
    });

    it('should ignore NaN input in setA/setB', () => {
      const prevA = component.a();
      const prevB = component.b();
      component.setA("not-a-number");
      component.setB({});
      expect(component.a()).toBe(prevA);
      expect(component.b()).toBe(prevB);
    });
  });
});